diff -Naur env/crc32.c env2/crc32.c
--- env/crc32.c	2014-12-10 18:33:58.524994206 -0700
+++ env2/crc32.c	1969-12-31 17:00:00.000000000 -0700
@@ -1,229 +0,0 @@
-/*
- * This file is derived from crc32.c from the zlib-1.1.3 distribution
- * by Jean-loup Gailly and Mark Adler.
- */
-
-/* crc32.c -- compute the CRC-32 of a data stream
- * Copyright (C) 1995-1998 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-#ifndef USE_HOSTCC	/* Shut down "ANSI does not permit..." warnings */
-#include <common.h>
-#else
-#include <stdint.h>
-#endif
-
-#if defined(CONFIG_HW_WATCHDOG) || defined(CONFIG_WATCHDOG)
-#include <watchdog.h>
-#endif
-#include "zlib.h"
-
-#define local static
-#define ZEXPORT	/* empty */
-
-#ifdef DYNAMIC_CRC_TABLE
-
-local int crc_table_empty = 1;
-local uint32_t crc_table[256];
-local void make_crc_table OF((void));
-
-/*
-  Generate a table for a byte-wise 32-bit CRC calculation on the polynomial:
-  x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1.
-
-  Polynomials over GF(2) are represented in binary, one bit per coefficient,
-  with the lowest powers in the most significant bit.  Then adding polynomials
-  is just exclusive-or, and multiplying a polynomial by x is a right shift by
-  one.  If we call the above polynomial p, and represent a byte as the
-  polynomial q, also with the lowest power in the most significant bit (so the
-  byte 0xb1 is the polynomial x^7+x^3+x+1), then the CRC is (q*x^32) mod p,
-  where a mod b means the remainder after dividing a by b.
-
-  This calculation is done using the shift-register method of multiplying and
-  taking the remainder.  The register is initialized to zero, and for each
-  incoming bit, x^32 is added mod p to the register if the bit is a one (where
-  x^32 mod p is p+x^32 = x^26+...+1), and the register is multiplied mod p by
-  x (which is shifting right by one and adding x^32 mod p if the bit shifted
-  out is a one).  We start with the highest power (least significant bit) of
-  q and repeat for all eight bits of q.
-
-  The table is simply the CRC of all possible eight bit values.  This is all
-  the information needed to generate CRC's on data a byte at a time for all
-  combinations of CRC register values and incoming bytes.
-*/
-local void make_crc_table()
-{
-  uint32_t c;
-  int n, k;
-  uLong poly;		/* polynomial exclusive-or pattern */
-  /* terms of polynomial defining this crc (except x^32): */
-  static const Byte p[] = {0,1,2,4,5,7,8,10,11,12,16,22,23,26};
-
-  /* make exclusive-or pattern from polynomial (0xedb88320L) */
-  poly = 0L;
-  for (n = 0; n < sizeof(p)/sizeof(Byte); n++)
-    poly |= 1L << (31 - p[n]);
-
-  for (n = 0; n < 256; n++)
-  {
-    c = (uLong)n;
-    for (k = 0; k < 8; k++)
-      c = c & 1 ? poly ^ (c >> 1) : c >> 1;
-    crc_table[n] = c;
-  }
-  crc_table_empty = 0;
-}
-#else
-/* ========================================================================
- * Table of CRC-32's of all single-byte values (made by make_crc_table)
- */
-local const uint32_t crc_table[256] = {
-  0x00000000L, 0x77073096L, 0xee0e612cL, 0x990951baL, 0x076dc419L,
-  0x706af48fL, 0xe963a535L, 0x9e6495a3L, 0x0edb8832L, 0x79dcb8a4L,
-  0xe0d5e91eL, 0x97d2d988L, 0x09b64c2bL, 0x7eb17cbdL, 0xe7b82d07L,
-  0x90bf1d91L, 0x1db71064L, 0x6ab020f2L, 0xf3b97148L, 0x84be41deL,
-  0x1adad47dL, 0x6ddde4ebL, 0xf4d4b551L, 0x83d385c7L, 0x136c9856L,
-  0x646ba8c0L, 0xfd62f97aL, 0x8a65c9ecL, 0x14015c4fL, 0x63066cd9L,
-  0xfa0f3d63L, 0x8d080df5L, 0x3b6e20c8L, 0x4c69105eL, 0xd56041e4L,
-  0xa2677172L, 0x3c03e4d1L, 0x4b04d447L, 0xd20d85fdL, 0xa50ab56bL,
-  0x35b5a8faL, 0x42b2986cL, 0xdbbbc9d6L, 0xacbcf940L, 0x32d86ce3L,
-  0x45df5c75L, 0xdcd60dcfL, 0xabd13d59L, 0x26d930acL, 0x51de003aL,
-  0xc8d75180L, 0xbfd06116L, 0x21b4f4b5L, 0x56b3c423L, 0xcfba9599L,
-  0xb8bda50fL, 0x2802b89eL, 0x5f058808L, 0xc60cd9b2L, 0xb10be924L,
-  0x2f6f7c87L, 0x58684c11L, 0xc1611dabL, 0xb6662d3dL, 0x76dc4190L,
-  0x01db7106L, 0x98d220bcL, 0xefd5102aL, 0x71b18589L, 0x06b6b51fL,
-  0x9fbfe4a5L, 0xe8b8d433L, 0x7807c9a2L, 0x0f00f934L, 0x9609a88eL,
-  0xe10e9818L, 0x7f6a0dbbL, 0x086d3d2dL, 0x91646c97L, 0xe6635c01L,
-  0x6b6b51f4L, 0x1c6c6162L, 0x856530d8L, 0xf262004eL, 0x6c0695edL,
-  0x1b01a57bL, 0x8208f4c1L, 0xf50fc457L, 0x65b0d9c6L, 0x12b7e950L,
-  0x8bbeb8eaL, 0xfcb9887cL, 0x62dd1ddfL, 0x15da2d49L, 0x8cd37cf3L,
-  0xfbd44c65L, 0x4db26158L, 0x3ab551ceL, 0xa3bc0074L, 0xd4bb30e2L,
-  0x4adfa541L, 0x3dd895d7L, 0xa4d1c46dL, 0xd3d6f4fbL, 0x4369e96aL,
-  0x346ed9fcL, 0xad678846L, 0xda60b8d0L, 0x44042d73L, 0x33031de5L,
-  0xaa0a4c5fL, 0xdd0d7cc9L, 0x5005713cL, 0x270241aaL, 0xbe0b1010L,
-  0xc90c2086L, 0x5768b525L, 0x206f85b3L, 0xb966d409L, 0xce61e49fL,
-  0x5edef90eL, 0x29d9c998L, 0xb0d09822L, 0xc7d7a8b4L, 0x59b33d17L,
-  0x2eb40d81L, 0xb7bd5c3bL, 0xc0ba6cadL, 0xedb88320L, 0x9abfb3b6L,
-  0x03b6e20cL, 0x74b1d29aL, 0xead54739L, 0x9dd277afL, 0x04db2615L,
-  0x73dc1683L, 0xe3630b12L, 0x94643b84L, 0x0d6d6a3eL, 0x7a6a5aa8L,
-  0xe40ecf0bL, 0x9309ff9dL, 0x0a00ae27L, 0x7d079eb1L, 0xf00f9344L,
-  0x8708a3d2L, 0x1e01f268L, 0x6906c2feL, 0xf762575dL, 0x806567cbL,
-  0x196c3671L, 0x6e6b06e7L, 0xfed41b76L, 0x89d32be0L, 0x10da7a5aL,
-  0x67dd4accL, 0xf9b9df6fL, 0x8ebeeff9L, 0x17b7be43L, 0x60b08ed5L,
-  0xd6d6a3e8L, 0xa1d1937eL, 0x38d8c2c4L, 0x4fdff252L, 0xd1bb67f1L,
-  0xa6bc5767L, 0x3fb506ddL, 0x48b2364bL, 0xd80d2bdaL, 0xaf0a1b4cL,
-  0x36034af6L, 0x41047a60L, 0xdf60efc3L, 0xa867df55L, 0x316e8eefL,
-  0x4669be79L, 0xcb61b38cL, 0xbc66831aL, 0x256fd2a0L, 0x5268e236L,
-  0xcc0c7795L, 0xbb0b4703L, 0x220216b9L, 0x5505262fL, 0xc5ba3bbeL,
-  0xb2bd0b28L, 0x2bb45a92L, 0x5cb36a04L, 0xc2d7ffa7L, 0xb5d0cf31L,
-  0x2cd99e8bL, 0x5bdeae1dL, 0x9b64c2b0L, 0xec63f226L, 0x756aa39cL,
-  0x026d930aL, 0x9c0906a9L, 0xeb0e363fL, 0x72076785L, 0x05005713L,
-  0x95bf4a82L, 0xe2b87a14L, 0x7bb12baeL, 0x0cb61b38L, 0x92d28e9bL,
-  0xe5d5be0dL, 0x7cdcefb7L, 0x0bdbdf21L, 0x86d3d2d4L, 0xf1d4e242L,
-  0x68ddb3f8L, 0x1fda836eL, 0x81be16cdL, 0xf6b9265bL, 0x6fb077e1L,
-  0x18b74777L, 0x88085ae6L, 0xff0f6a70L, 0x66063bcaL, 0x11010b5cL,
-  0x8f659effL, 0xf862ae69L, 0x616bffd3L, 0x166ccf45L, 0xa00ae278L,
-  0xd70dd2eeL, 0x4e048354L, 0x3903b3c2L, 0xa7672661L, 0xd06016f7L,
-  0x4969474dL, 0x3e6e77dbL, 0xaed16a4aL, 0xd9d65adcL, 0x40df0b66L,
-  0x37d83bf0L, 0xa9bcae53L, 0xdebb9ec5L, 0x47b2cf7fL, 0x30b5ffe9L,
-  0xbdbdf21cL, 0xcabac28aL, 0x53b39330L, 0x24b4a3a6L, 0xbad03605L,
-  0xcdd70693L, 0x54de5729L, 0x23d967bfL, 0xb3667a2eL, 0xc4614ab8L,
-  0x5d681b02L, 0x2a6f2b94L, 0xb40bbe37L, 0xc30c8ea1L, 0x5a05df1bL,
-  0x2d02ef8dL
-};
-#endif
-
-#if 0
-/* =========================================================================
- * This function can be used by asm versions of crc32()
- */
-const uint32_t * ZEXPORT get_crc_table()
-{
-#ifdef DYNAMIC_CRC_TABLE
-  if (crc_table_empty) make_crc_table();
-#endif
-  return (const uint32_t *)crc_table;
-}
-#endif
-
-/* ========================================================================= */
-#define DO1(buf) crc = crc_table[((int)crc ^ (*buf++)) & 0xff] ^ (crc >> 8);
-#define DO2(buf)  DO1(buf); DO1(buf);
-#define DO4(buf)  DO2(buf); DO2(buf);
-#define DO8(buf)  DO4(buf); DO4(buf);
-
-/* ========================================================================= */
-uint32_t ZEXPORT crc32 (uint32_t crc, const Bytef *buf, uInt len)
-{
-#ifdef DYNAMIC_CRC_TABLE
-    if (crc_table_empty)
-      make_crc_table();
-#endif
-    crc = crc ^ 0xffffffffL;
-    while (len >= 8)
-    {
-      DO8(buf);
-      len -= 8;
-    }
-    if (len) do {
-      DO1(buf);
-    } while (--len);
-    return crc ^ 0xffffffffL;
-}
-
-#if defined(CONFIG_CMD_JFFS2) || \
-	(defined(CONFIG_CMD_NAND) \
-	&& !defined(CFG_NAND_LEGACY))
-
-/* No ones complement version. JFFS2 (and other things ?)
- * don't use ones compliment in their CRC calculations.
- */
-uint32_t ZEXPORT crc32_no_comp(uint32_t crc, const Bytef *buf, uInt len)
-{
-#ifdef DYNAMIC_CRC_TABLE
-    if (crc_table_empty)
-      make_crc_table();
-#endif
-    while (len >= 8)
-    {
-      DO8(buf);
-      len -= 8;
-    }
-    if (len) do {
-      DO1(buf);
-    } while (--len);
-
-    return crc;
-}
-
-#endif
-
-/*
- * Calculate the crc32 checksum triggering the watchdog every 'chunk_sz' bytes
- * of input.
- */
-uint32_t ZEXPORT crc32_wd (uint32_t crc,
-			   const unsigned char *buf,
-			   uInt len, uInt chunk_sz)
-{
-#if defined(CONFIG_HW_WATCHDOG) || defined(CONFIG_WATCHDOG)
-	const unsigned char *end, *curr;
-	int chunk;
-
-	curr = buf;
-	end = buf + len;
-	while (curr < end) {
-		chunk = end - curr;
-		if (chunk > chunk_sz)
-			chunk = chunk_sz;
-		crc = crc32 (crc, curr, chunk);
-		curr += chunk;
-		WATCHDOG_RESET ();
-	}
-#else
-	crc = crc32 (crc, buf, len);
-#endif
-
-	return crc;
-}
diff -Naur env/.depend env2/.depend
--- env/.depend	2015-04-28 17:16:04.431851397 -0700
+++ env2/.depend	1969-12-31 17:00:00.000000000 -0700
@@ -1,101 +0,0 @@
-crc32.o: crc32.c \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/stdint.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/features.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/bits/predefs.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/sys/cdefs.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/bits/wordsize.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/gnu/stubs.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/bits/wchar.h \
- /home/chaol/Development/repo/synergy2416-uboot/include/zlib.h
-fw_env.o: fw_env.c \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/errno.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/features.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/bits/predefs.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/sys/cdefs.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/bits/wordsize.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/gnu/stubs.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/bits/errno.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/linux/errno.h \
- /home/chaol/Development/repo/synergy2416-uboot/include/asm/errno.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/fcntl.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/bits/fcntl.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/sys/types.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/bits/types.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/bits/typesizes.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/time.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../lib/gcc/arm-none-linux-gnueabi/4.4.1/include/stddef.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/endian.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/bits/endian.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/bits/byteswap.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/sys/select.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/bits/select.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/bits/sigset.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/bits/time.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/sys/sysmacros.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/bits/pthreadtypes.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/stdio.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/libio.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/_G_config.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/wchar.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../lib/gcc/arm-none-linux-gnueabi/4.4.1/include/stdarg.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/bits/stdio_lim.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/bits/sys_errlist.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/stdlib.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/alloca.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/string.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/xlocale.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/sys/ioctl.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/bits/ioctls.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/asm/ioctls.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/asm/ioctl.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/asm-generic/ioctl.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/bits/ioctl-types.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/sys/ttydefaults.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/sys/stat.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/bits/stat.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/unistd.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/bits/posix_opt.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/bits/confname.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/getopt.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/mtd/mtd-user.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/stdint.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/bits/wchar.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/mtd/mtd-abi.h \
- /home/chaol/Development/repo/synergy2416-uboot/include/linux/types.h \
- /home/chaol/Development/repo/synergy2416-uboot/include/linux/posix_types.h \
- /home/chaol/Development/repo/synergy2416-uboot/include/linux/stddef.h \
- /home/chaol/Development/repo/synergy2416-uboot/include/asm/posix_types.h \
- /home/chaol/Development/repo/synergy2416-uboot/include/asm/types.h \
- fw_env.h
-fw_env_main.o: fw_env_main.c \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/stdio.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/features.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/bits/predefs.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/sys/cdefs.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/bits/wordsize.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/gnu/stubs.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../lib/gcc/arm-none-linux-gnueabi/4.4.1/include/stddef.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/bits/types.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/bits/typesizes.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/libio.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/_G_config.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/wchar.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../lib/gcc/arm-none-linux-gnueabi/4.4.1/include/stdarg.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/bits/stdio_lim.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/bits/sys_errlist.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/string.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/xlocale.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/stdlib.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/sys/types.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/time.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/endian.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/bits/endian.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/bits/byteswap.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/sys/select.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/bits/select.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/bits/sigset.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/bits/time.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/sys/sysmacros.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/bits/pthreadtypes.h \
- /home/chaol/CodeSourcery/Sourcery_G++_Lite/bin/../arm-none-linux-gnueabi/libc/usr/include/alloca.h \
- fw_env.h
diff -Naur env/fw_env.c env2/fw_env.c
--- env/fw_env.c	2015-04-28 17:16:01.419851340 -0700
+++ env2/fw_env.c	2009-01-28 12:44:51.000000000 -0700
@@ -2,6 +2,9 @@
  * (C) Copyright 2000-2008
  * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
  *
+ * (C) Copyright 2008
+ * Guennadi Liakhovetski, DENX Software Engineering, lg@denx.de.
+ *
  * See file CREDITS for list of people who contributed to this
  * project.
  *
@@ -33,6 +36,7 @@
 #include <unistd.h>
 
 #ifdef MTD_OLD
+# include <stdint.h>
 # include <linux/mtd/mtd.h>
 #else
 # define  __user	/* nothing */
@@ -44,36 +48,75 @@
 #define	CMD_GETENV	"fw_printenv"
 #define	CMD_SETENV	"fw_setenv"
 
-typedef struct envdev_s {
+#define min(x, y) ({				\
+	typeof(x) _min1 = (x);			\
+	typeof(y) _min2 = (y);			\
+	(void) (&_min1 == &_min2);		\
+	_min1 < _min2 ? _min1 : _min2; })
+
+struct envdev_s {
 	char devname[16];		/* Device name */
 	ulong devoff;			/* Device offset */
 	ulong env_size;			/* environment size */
 	ulong erase_size;		/* device erase size */
-} envdev_t;
+	ulong env_sectors;		/* number of environment sectors */
+	uint8_t mtd_type;		/* type of the MTD device */
+};
 
-static envdev_t envdevices[2];
-static int curdev;
+static struct envdev_s envdevices[2] =
+{
+	{
+		.mtd_type = MTD_ABSENT,
+	}, {
+		.mtd_type = MTD_ABSENT,
+	},
+};
+static int dev_current;
 
 #define DEVNAME(i)    envdevices[(i)].devname
 #define DEVOFFSET(i)  envdevices[(i)].devoff
 #define ENVSIZE(i)    envdevices[(i)].env_size
 #define DEVESIZE(i)   envdevices[(i)].erase_size
+#define ENVSECTORS(i) envdevices[(i)].env_sectors
+#define DEVTYPE(i)    envdevices[(i)].mtd_type
 
-#define CFG_ENV_SIZE ENVSIZE(curdev)
+#define CONFIG_ENV_SIZE ENVSIZE(dev_current)
 
 #define ENV_SIZE      getenvsize()
 
-typedef struct environment_s {
-	ulong crc;			/* CRC32 over data bytes    */
-	unsigned char flags;		/* active or obsolete */
-	char *data;
-} env_t;
+struct env_image_single {
+	uint32_t	crc;	/* CRC32 over data bytes    */
+	char		data[];
+};
 
-static env_t environment;
+struct env_image_redundant {
+	uint32_t	crc;	/* CRC32 over data bytes    */
+	unsigned char	flags;	/* active or obsolete */
+	char		data[];
+};
+
+enum flag_scheme {
+	FLAG_NONE,
+	FLAG_BOOLEAN,
+	FLAG_INCREMENTAL,
+};
+
+struct environment {
+	void			*image;
+	uint32_t		*crc;
+	unsigned char		*flags;
+	char			*data;
+	enum flag_scheme	flag_scheme;
+};
+
+static struct environment environment = {
+	.flag_scheme = FLAG_NONE,
+};
 
 static int HaveRedundEnv = 0;
 
 static unsigned char active_flag = 1;
+/* obsolete_flag must be 0 to efficiently set it on NOR flash without erasing */
 static unsigned char obsolete_flag = 0;
 
 
@@ -114,6 +157,12 @@
 #ifdef	CONFIG_ETH3ADDR
 	"eth3addr=" MK_STR (CONFIG_ETH3ADDR) "\0"
 #endif
+#ifdef	CONFIG_ETH4ADDR
+	"eth4addr=" MK_STR (CONFIG_ETH4ADDR) "\0"
+#endif
+#ifdef	CONFIG_ETH5ADDR
+	"eth5addr=" MK_STR (CONFIG_ETH5ADDR) "\0"
+#endif
 #ifdef	CONFIG_ETHPRIME
 	"ethprime=" CONFIG_ETHPRIME "\0"
 #endif
@@ -123,8 +172,8 @@
 #ifdef	CONFIG_SERVERIP
 	"serverip=" MK_STR (CONFIG_SERVERIP) "\0"
 #endif
-#ifdef	CFG_AUTOLOAD
-	"autoload=" CFG_AUTOLOAD "\0"
+#ifdef	CONFIG_SYS_AUTOLOAD
+	"autoload=" CONFIG_SYS_AUTOLOAD "\0"
 #endif
 #ifdef	CONFIG_ROOTPATH
 	"rootpath=" MK_STR (CONFIG_ROOTPATH) "\0"
@@ -156,7 +205,7 @@
 #ifdef  CONFIG_EXTRA_ENV_SETTINGS
 	CONFIG_EXTRA_ENV_SETTINGS
 #endif
-	"\0"			/* Termimate env_t data with 2 NULs */
+	"\0"		/* Termimate struct environment data with 2 NULs */
 };
 
 static int flash_io (int mode);
@@ -169,7 +218,7 @@
 #endif
 static inline ulong getenvsize (void)
 {
-	ulong rc = CFG_ENV_SIZE - sizeof (long);
+	ulong rc = CONFIG_ENV_SIZE - sizeof (long);
 
 	if (HaveRedundEnv)
 		rc -= sizeof (char);
@@ -185,7 +234,7 @@
 	char *env, *nxt;
 
 	if (env_init ())
-		return (NULL);
+		return NULL;
 
 	for (env = environment.data; *env; env = nxt + 1) {
 		char *val;
@@ -194,15 +243,15 @@
 			if (nxt >= &environment.data[ENV_SIZE]) {
 				fprintf (stderr, "## Error: "
 					"environment not terminated\n");
-				return (NULL);
+				return NULL;
 			}
 		}
 		val = envmatch (name, env);
 		if (!val)
 			continue;
-		return (val);
+		return val;
 	}
-	return (NULL);
+	return NULL;
 }
 
 /*
@@ -216,7 +265,7 @@
 	int rc = 0;
 
 	if (env_init ())
-		return (-1);
+		return -1;
 
 	if (argc == 1) {		/* Print all env variables  */
 		for (env = environment.data; *env; env = nxt + 1) {
@@ -224,13 +273,13 @@
 				if (nxt >= &environment.data[ENV_SIZE]) {
 					fprintf (stderr, "## Error: "
 						"environment not terminated\n");
-					return (-1);
+					return -1;
 				}
 			}
 
 			printf ("%s\n", env);
 		}
-		return (0);
+		return 0;
 	}
 
 	if (strcmp (argv[1], "-n") == 0) {
@@ -240,7 +289,7 @@
 		if (argc != 2) {
 			fprintf (stderr, "## Error: "
 				"`-n' option requires exactly one argument\n");
-			return (-1);
+			return -1;
 		}
 	} else {
 		n_flag = 0;
@@ -256,7 +305,7 @@
 				if (nxt >= &environment.data[ENV_SIZE]) {
 					fprintf (stderr, "## Error: "
 						"environment not terminated\n");
-					return (-1);
+					return -1;
 				}
 			}
 			val = envmatch (name, env);
@@ -275,11 +324,11 @@
 		}
 	}
 
-	return (rc);
+	return rc;
 }
 
 /*
- * Deletes or sets environment variables. Returns errno style error codes:
+ * Deletes or sets environment variables. Returns -1 and sets errno error codes:
  * 0	  - OK
  * EINVAL - need at least 1 argument
  * EROFS  - certain variables ("ethaddr", "serial#") cannot be
@@ -294,11 +343,12 @@
 	char *name;
 
 	if (argc < 2) {
-		return (EINVAL);
+		errno = EINVAL;
+		return -1;
 	}
 
 	if (env_init ())
-		return (errno);
+		return -1;
 
 	name = argv[1];
 
@@ -310,7 +360,8 @@
 			if (nxt >= &environment.data[ENV_SIZE]) {
 				fprintf (stderr, "## Error: "
 					"environment not terminated\n");
-				return (EINVAL);
+				errno = EINVAL;
+				return -1;
 			}
 		}
 		if ((oldval = envmatch (name, env)) != NULL)
@@ -324,10 +375,11 @@
 		/*
 		 * Ethernet Address and serial# can be set only once
 		 */
-		//#if ((strcmp (name, "ethaddr") == 0) ||
-		if (strcmp (name, "serial#") == 0) {
+		if ((strcmp (name, "ethaddr") == 0) ||
+			(strcmp (name, "serial#") == 0)) {
 			fprintf (stderr, "Can't overwrite \"%s\"\n", name);
-			return (EROFS);
+			errno = EROFS;
+			return -1;
 		}
 
 		if (*++nxt == '\0') {
@@ -355,7 +407,7 @@
 		++env;
 	/*
 	 * Overflow when:
-	 * "name" + "=" + "val" +"\0\0"  > CFG_ENV_SIZE - (env-environment)
+	 * "name" + "=" + "val" +"\0\0"  > CONFIG_ENV_SIZE - (env-environment)
 	 */
 	len = strlen (name) + 2;
 	/* add '=' for first arg, ' ' for all others */
@@ -366,7 +418,7 @@
 		fprintf (stderr,
 			"Error: environment overflow, \"%s\" deleted\n",
 			name);
-		return (-1);
+		return -1;
 	}
 	while ((*env = *name++) != '\0')
 		env++;
@@ -382,198 +434,430 @@
 
   WRITE_FLASH:
 
-	/* Update CRC */
-	environment.crc = crc32 (0, (uint8_t*) environment.data, ENV_SIZE);
-	fprintf(stderr,
-		"updated crc is %ld\n env size is %ld\n",
-		 environment.crc, ENV_SIZE);
+	/*
+	 * Update CRC
+	 */
+	*environment.crc = crc32 (0, (uint8_t *) environment.data, ENV_SIZE);
 
 	/* write environment back to flash */
 	if (flash_io (O_RDWR)) {
 		fprintf (stderr, "Error: can't write fw_env to flash\n");
-		return (-1);
+		return -1;
 	}
 
-	return (0);
+	return 0;
 }
 
-static int flash_io (int mode)
+/*
+ * Test for bad block on NAND, just returns 0 on NOR, on NAND:
+ * 0	- block is good
+ * > 0	- block is bad
+ * < 0	- failed to test
+ */
+static int flash_bad_block (int fd, uint8_t mtd_type, loff_t *blockstart)
 {
-	int fd, fdr, rc, otherdev, len, resid, crclen;
-	erase_info_t erase;
-	char *data = NULL;
+	if (mtd_type == MTD_NANDFLASH) {
+		int badblock = ioctl (fd, MEMGETBADBLOCK, blockstart);
 
-	if ((fd = open (DEVNAME (curdev), mode)) < 0) {
-		fprintf (stderr,
-			"Can't open %s: %s\n",
-			DEVNAME (curdev), strerror (errno));
-		return (-1);
+		if (badblock < 0) {
+			perror ("Cannot read bad block mark");
+			return badblock;
+		}
+
+		if (badblock) {
+#ifdef DEBUG
+			fprintf (stderr, "Bad block at 0x%llx, "
+				 "skipping\n", *blockstart);
+#endif
+			return badblock;
+		}
 	}
 
-	len = sizeof (environment.crc);
-	if (HaveRedundEnv) {
-		len += sizeof (environment.flags);
+	return 0;
+}
+
+/*
+ * Read data from flash at an offset into a provided buffer. On NAND it skips
+ * bad blocks but makes sure it stays within ENVSECTORS (dev) starting from
+ * the DEVOFFSET (dev) block. On NOR the loop is only run once.
+ */
+static int flash_read_buf (int dev, int fd, void *buf, size_t count,
+			   off_t offset, uint8_t mtd_type)
+{
+	size_t blocklen;	/* erase / write length - one block on NAND,
+				   0 on NOR */
+	size_t processed = 0;	/* progress counter */
+	size_t readlen = count;	/* current read length */
+	off_t top_of_range;	/* end of the last block we may use */
+	off_t block_seek;	/* offset inside the current block to the start
+				   of the data */
+	loff_t blockstart;	/* running start of the current block -
+				   MEMGETBADBLOCK needs 64 bits */
+	int rc;
+
+	/*
+	 * Start of the first block to be read, relies on the fact, that
+	 * erase sector size is always a power of 2
+	 */
+	blockstart = offset & ~(DEVESIZE (dev) - 1);
+
+	/* Offset inside a block */
+	block_seek = offset - blockstart;
+
+	if (mtd_type == MTD_NANDFLASH) {
+		/*
+		 * NAND: calculate which blocks we are reading. We have
+		 * to read one block at a time to skip bad blocks.
+		 */
+		blocklen = DEVESIZE (dev);
+
+		/*
+		 * To calculate the top of the range, we have to use the
+		 * global DEVOFFSET (dev), which can be different from offset
+		 */
+		top_of_range = (DEVOFFSET (dev) & ~(blocklen - 1)) +
+			ENVSECTORS (dev) * blocklen;
+
+		/* Limit to one block for the first read */
+		if (readlen > blocklen - block_seek)
+			readlen = blocklen - block_seek;
+	} else {
+		blocklen = 0;
+		top_of_range = offset + count;
 	}
 
-	if (mode == O_RDWR) {
-		if (HaveRedundEnv) {
-			/* switch to next partition for writing */
-			otherdev = !curdev;
-			if ((fdr = open (DEVNAME (otherdev), mode)) < 0) {
-				fprintf (stderr,
-					"Can't open %s: %s\n",
-					DEVNAME (otherdev),
-					strerror (errno));
-				return (-1);
-			}
-		} else {
-			otherdev = curdev;
-			fdr = fd;
-		}
-		printf ("Unlocking flash...\n");
-		erase.length = DEVESIZE (otherdev);
-		erase.start = DEVOFFSET (otherdev);
-		ioctl (fdr, MEMUNLOCK, &erase);
+	/* This only runs once on NOR flash */
+	while (processed < count) {
+		rc = flash_bad_block (fd, mtd_type, &blockstart);
+		if (rc < 0)		/* block test failed */
+			return -1;
 
-		if (HaveRedundEnv) {
-			erase.length = DEVESIZE (curdev);
-			erase.start = DEVOFFSET (curdev);
-			ioctl (fd, MEMUNLOCK, &erase);
-			environment.flags = active_flag;
+		if (blockstart + block_seek + readlen > top_of_range) {
+			/* End of range is reached */
+			fprintf (stderr,
+				 "Too few good blocks within range\n");
+			return -1;
 		}
 
-		printf ("Done\n");
-		resid = DEVESIZE (otherdev) - CFG_ENV_SIZE;
-		if (resid) {
-			if ((data = malloc (resid)) == NULL) {
-				fprintf (stderr,
-					"Cannot malloc %d bytes: %s\n",
-					resid,
-					strerror (errno));
-				return (-1);
-			}
-			if (lseek (fdr, DEVOFFSET (otherdev) + CFG_ENV_SIZE, SEEK_SET)
-				== -1) {
-				fprintf (stderr, "seek error on %s: %s\n",
-					DEVNAME (otherdev),
-					strerror (errno));
-				return (-1);
-			}
-			if ((rc = read (fdr, data, resid)) != resid) {
-				fprintf (stderr,
-					"read error on %s: %s\n",
-					DEVNAME (otherdev),
-					strerror (errno));
-				return (-1);
-			}
+		if (rc) {		/* block is bad */
+			blockstart += blocklen;
+			continue;
 		}
 
-		printf ("Erasing old environment...\n");
+		/*
+		 * If a block is bad, we retry in the next block at the same
+		 * offset - see common/env_nand.c::writeenv()
+		 */
+		lseek (fd, blockstart + block_seek, SEEK_SET);
 
-		erase.length = DEVESIZE (otherdev);
-		erase.start = DEVOFFSET (otherdev);
-		if (ioctl (fdr, MEMERASE, &erase) != 0) {
-			fprintf (stderr, "MTD erase error on %s: %s\n",
-				DEVNAME (otherdev),
-				strerror (errno));
-			return (-1);
+		rc = read (fd, buf + processed, readlen);
+		if (rc != readlen) {
+			fprintf (stderr, "Read error on %s: %s\n",
+				 DEVNAME (dev), strerror (errno));
+			return -1;
 		}
+#ifdef DEBUG
+		fprintf (stderr, "Read 0x%x bytes at 0x%llx\n",
+			 rc, blockstart + block_seek);
+#endif
+		processed += readlen;
+		readlen = min (blocklen, count - processed);
+		block_seek = 0;
+		blockstart += blocklen;
+	}
+
+	return processed;
+}
+
+/*
+ * Write count bytes at offset, but stay within ENVSETCORS (dev) sectors of
+ * DEVOFFSET (dev). Similar to the read case above, on NOR we erase and write
+ * the whole data at once.
+ */
+static int flash_write_buf (int dev, int fd, void *buf, size_t count,
+			    off_t offset, uint8_t mtd_type)
+{
+	void *data;
+	struct erase_info_user erase;
+	size_t blocklen;	/* length of NAND block / NOR erase sector */
+	size_t erase_len;	/* whole area that can be erased - may include
+				   bad blocks */
+	size_t erasesize;	/* erase / write length - one block on NAND,
+				   whole area on NOR */
+	size_t processed = 0;	/* progress counter */
+	size_t write_total;	/* total size to actually write - excludinig
+				   bad blocks */
+	off_t erase_offset;	/* offset to the first erase block (aligned)
+				   below offset */
+	off_t block_seek;	/* offset inside the erase block to the start
+				   of the data */
+	off_t top_of_range;	/* end of the last block we may use */
+	loff_t blockstart;	/* running start of the current block -
+				   MEMGETBADBLOCK needs 64 bits */
+	int rc;
+
+	blocklen = DEVESIZE (dev);
+
+	/* Erase sector size is always a power of 2 */
+	top_of_range = (DEVOFFSET (dev) & ~(blocklen - 1)) +
+		ENVSECTORS (dev) * blocklen;
+
+	erase_offset = offset & ~(blocklen - 1);
 
-		printf ("Done\n");
+	/* Maximum area we may use */
+	erase_len = top_of_range - erase_offset;
 
-		printf ("Writing environment to %s...\n with offset: %lu\n",DEVNAME (otherdev),DEVOFFSET(otherdev));
-		if (lseek (fdr, DEVOFFSET (otherdev), SEEK_SET) == -1) {
+	blockstart = erase_offset;
+	/* Offset inside a block */
+	block_seek = offset - erase_offset;
+
+	/*
+	 * Data size we actually have to write: from the start of the block
+	 * to the start of the data, then count bytes of data, and to the
+	 * end of the block
+	 */
+	write_total = (block_seek + count + blocklen - 1) & ~(blocklen - 1);
+
+	/*
+	 * Support data anywhere within erase sectors: read out the complete
+	 * area to be erased, replace the environment image, write the whole
+	 * block back again.
+	 */
+	if (write_total > count) {
+		data = malloc (erase_len);
+		if (!data) {
 			fprintf (stderr,
-				"seek error on %s: %s\n",
-				DEVNAME (otherdev), strerror (errno));
-			return (-1);
+				 "Cannot malloc %u bytes: %s\n",
+				 erase_len, strerror (errno));
+			return -1;
 		}
-		if ((crclen = write (fdr, &(environment.crc), len)) != len) {
-			fprintf (stderr,
-				"CRC write error on %s: %s\n wrote %d/%d bytes only \n",
-				DEVNAME (otherdev), strerror (errno), crclen,len);
-			return (-1);
+
+		rc = flash_read_buf (dev, fd, data, write_total, erase_offset,
+				     mtd_type);
+		if (write_total != rc)
+			return -1;
+
+		/* Overwrite the old environment */
+		memcpy (data + block_seek, buf, count);
+	} else {
+		/*
+		 * We get here, iff offset is block-aligned and count is a
+		 * multiple of blocklen - see write_total calculation above
+		 */
+		data = buf;
+	}
+
+	if (mtd_type == MTD_NANDFLASH) {
+		/*
+		 * NAND: calculate which blocks we are writing. We have
+		 * to write one block at a time to skip bad blocks.
+		 */
+		erasesize = blocklen;
+	} else {
+		erasesize = erase_len;
+	}
+
+	erase.length = erasesize;
+
+	/* This only runs once on NOR flash */
+	while (processed < write_total) {
+		rc = flash_bad_block (fd, mtd_type, &blockstart);
+		if (rc < 0)		/* block test failed */
+			return rc;
+
+		if (blockstart + erasesize > top_of_range) {
+			fprintf (stderr, "End of range reached, aborting\n");
+			return -1;
 		}
-		if (write (fdr, environment.data, ENV_SIZE) != ENV_SIZE) {
+
+		if (rc) {		/* block is bad */
+			blockstart += blocklen;
+			continue;
+		}
+
+		erase.start = blockstart;
+		ioctl (fd, MEMUNLOCK, &erase);
+
+		if (ioctl (fd, MEMERASE, &erase) != 0) {
+			fprintf (stderr, "MTD erase error on %s: %s\n",
+				 DEVNAME (dev),
+				 strerror (errno));
+			return -1;
+		}
+
+		if (lseek (fd, blockstart, SEEK_SET) == -1) {
 			fprintf (stderr,
-				"Write env data error on %s: %s\n env size: %ld\n",
-				DEVNAME (otherdev), strerror (errno), ENV_SIZE);
-			return (-1);
+				 "Seek error on %s: %s\n",
+				 DEVNAME (dev), strerror (errno));
+			return -1;
 		}
-		if (resid) {
-			if (write (fdr, data, resid) != resid) {
-				fprintf (stderr,
-					"write error on %s: %s\n",
-					DEVNAME (curdev), strerror (errno));
-				return (-1);
-			}
-			free (data);
+
+#ifdef DEBUG
+		printf ("Write 0x%x bytes at 0x%llx\n", erasesize, blockstart);
+#endif
+		if (write (fd, data + processed, erasesize) != erasesize) {
+			fprintf (stderr, "Write error on %s: %s\n",
+				 DEVNAME (dev), strerror (errno));
+			return -1;
 		}
+
+		ioctl (fd, MEMLOCK, &erase);
+
+		processed  += blocklen;
+		block_seek = 0;
+		blockstart += blocklen;
+	}
+
+	if (write_total > count)
+		free (data);
+
+	return processed;
+}
+
+/*
+ * Set obsolete flag at offset - NOR flash only
+ */
+static int flash_flag_obsolete (int dev, int fd, off_t offset)
+{
+	int rc;
+
+	/* This relies on the fact, that obsolete_flag == 0 */
+	rc = lseek (fd, offset, SEEK_SET);
+	if (rc < 0) {
+		fprintf (stderr, "Cannot seek to set the flag on %s \n",
+			 DEVNAME (dev));
+		return rc;
+	}
+	rc = write (fd, &obsolete_flag, sizeof (obsolete_flag));
+	if (rc < 0)
+		perror ("Could not set obsolete flag");
+
+	return rc;
+}
+
+static int flash_write (int fd_current, int fd_target, int dev_target)
+{
+	int rc;
+
+	switch (environment.flag_scheme) {
+	case FLAG_NONE:
+		break;
+	case FLAG_INCREMENTAL:
+		(*environment.flags)++;
+		break;
+	case FLAG_BOOLEAN:
+		*environment.flags = active_flag;
+		break;
+	default:
+		fprintf (stderr, "Unimplemented flash scheme %u \n",
+			 environment.flag_scheme);
+		return -1;
+	}
+
+#ifdef DEBUG
+	printf ("Writing new environment at 0x%lx on %s\n",
+		DEVOFFSET (dev_target), DEVNAME (dev_target));
+#endif
+	rc = flash_write_buf (dev_target, fd_target, environment.image,
+			      CONFIG_ENV_SIZE, DEVOFFSET (dev_target),
+			      DEVTYPE(dev_target));
+	if (rc < 0)
+		return rc;
+
+	if (environment.flag_scheme == FLAG_BOOLEAN) {
+		/* Have to set obsolete flag */
+		off_t offset = DEVOFFSET (dev_current) +
+			offsetof (struct env_image_redundant, flags);
+#ifdef DEBUG
+		printf ("Setting obsolete flag in environment at 0x%lx on %s\n",
+			DEVOFFSET (dev_current), DEVNAME (dev_current));
+#endif
+		flash_flag_obsolete (dev_current, fd_current, offset);
+	}
+
+	return 0;
+}
+
+static int flash_read (int fd)
+{
+	struct mtd_info_user mtdinfo;
+	int rc;
+
+	rc = ioctl (fd, MEMGETINFO, &mtdinfo);
+	if (rc < 0) {
+		perror ("Cannot get MTD information");
+		return -1;
+	}
+
+	if (mtdinfo.type != MTD_NORFLASH && mtdinfo.type != MTD_NANDFLASH) {
+		fprintf (stderr, "Unsupported flash type %u\n", mtdinfo.type);
+		return -1;
+	}
+
+	DEVTYPE(dev_current) = mtdinfo.type;
+
+	rc = flash_read_buf (dev_current, fd, environment.image, CONFIG_ENV_SIZE,
+			     DEVOFFSET (dev_current), mtdinfo.type);
+
+	return (rc != CONFIG_ENV_SIZE) ? -1 : 0;
+}
+
+static int flash_io (int mode)
+{
+	int fd_current, fd_target, rc, dev_target;
+
+	/* dev_current: fd_current, erase_current */
+	fd_current = open (DEVNAME (dev_current), mode);
+	if (fd_current < 0) {
+		fprintf (stderr,
+			 "Can't open %s: %s\n",
+			 DEVNAME (dev_current), strerror (errno));
+		return -1;
+	}
+
+	if (mode == O_RDWR) {
 		if (HaveRedundEnv) {
-			/* change flag on current active env partition */
-			if (lseek (fd, DEVOFFSET (curdev) + sizeof (ulong), SEEK_SET)
-				== -1) {
-				fprintf (stderr, "seek error on %s: %s\n",
-					DEVNAME (curdev), strerror (errno));
-				return (-1);
-			}
-			if (write (fd, &obsolete_flag, sizeof (obsolete_flag)) !=
-				sizeof (obsolete_flag)) {
+			/* switch to next partition for writing */
+			dev_target = !dev_current;
+			/* dev_target: fd_target, erase_target */
+			fd_target = open (DEVNAME (dev_target), mode);
+			if (fd_target < 0) {
 				fprintf (stderr,
-					"Write error on %s: %s\n",
-					DEVNAME (curdev), strerror (errno));
-				return (-1);
+					 "Can't open %s: %s\n",
+					 DEVNAME (dev_target),
+					 strerror (errno));
+				rc = -1;
+				goto exit;
 			}
+		} else {
+			dev_target = dev_current;
+			fd_target = fd_current;
 		}
-		printf ("Done\n");
-		printf ("Locking ...\n");
-		erase.length = DEVESIZE (otherdev);
-		erase.start = DEVOFFSET (otherdev);
-		ioctl (fdr, MEMLOCK, &erase);
+
+		rc = flash_write (fd_current, fd_target, dev_target);
+
 		if (HaveRedundEnv) {
-			erase.length = DEVESIZE (curdev);
-			erase.start = DEVOFFSET (curdev);
-			ioctl (fd, MEMLOCK, &erase);
-			if (close (fdr)) {
+			if (close (fd_target)) {
 				fprintf (stderr,
 					"I/O error on %s: %s\n",
-					DEVNAME (otherdev),
+					DEVNAME (dev_target),
 					strerror (errno));
-				return (-1);
+				rc = -1;
 			}
 		}
-		printf ("Done\n");
 	} else {
-
-		if (lseek (fd, DEVOFFSET (curdev), SEEK_SET) == -1) {
-			fprintf (stderr,
-				"seek error on %s: %s\n",
-				DEVNAME (curdev), strerror (errno));
-			return (-1);
-		}
-		if (read (fd, &environment, len) != len) {
-			fprintf (stderr,
-				"CRC read error on %s: %s\n",
-				DEVNAME (curdev), strerror (errno));
-			return (-1);
-		}
-		if ((rc = read (fd, environment.data, ENV_SIZE)) != ENV_SIZE) {
-			fprintf (stderr,
-				"Read error on %s: %s\n",
-				DEVNAME (curdev), strerror (errno));
-			return (-1);
-		}
+		rc = flash_read (fd_current);
 	}
 
-	if (close (fd)) {
+exit:
+	if (close (fd_current)) {
 		fprintf (stderr,
-			"I/O error on %s: %s\n",
-			DEVNAME (curdev), strerror (errno));
-		return (-1);
+			 "I/O error on %s: %s\n",
+			 DEVNAME (dev_current), strerror (errno));
+		return -1;
 	}
 
-	/* everything ok */
-	return (0);
+	return rc;
 }
 
 /*
@@ -587,10 +871,10 @@
 
 	while (*s1 == *s2++)
 		if (*s1++ == '=')
-			return (s2);
+			return s2;
 	if (*s1 == '\0' && *(s2 - 1) == '=')
-		return (s2);
-	return (NULL);
+		return s2;
+	return NULL;
 }
 
 /*
@@ -598,111 +882,156 @@
  */
 static int env_init (void)
 {
+	int crc0, crc0_ok;
+	char flag0;
+	void *addr0;
+
 	int crc1, crc1_ok;
-	char *addr1;
+	char flag1;
+	void *addr1;
 
-	int crc2, crc2_ok;
-	char flag1, flag2, *addr2;
+	struct env_image_single *single;
+	struct env_image_redundant *redundant;
 
 	if (parse_config ())		/* should fill envdevices */
-		return 1;
+		return -1;
 
-	if ((addr1 = calloc (1, ENV_SIZE)) == NULL) {
+	addr0 = calloc (1, CONFIG_ENV_SIZE);
+	if (addr0 == NULL) {
 		fprintf (stderr,
 			"Not enough memory for environment (%ld bytes)\n",
-			ENV_SIZE);
-		return (errno);
+			CONFIG_ENV_SIZE);
+		return -1;
 	}
 
 	/* read environment from FLASH to local buffer */
-	environment.data = addr1;
-	curdev = 0;
-	if (flash_io (O_RDONLY)) {
-		return (errno);
+	environment.image = addr0;
+
+	if (HaveRedundEnv) {
+		redundant = addr0;
+		environment.crc		= &redundant->crc;
+		environment.flags	= &redundant->flags;
+		environment.data	= redundant->data;
+	} else {
+		single = addr0;
+		environment.crc		= &single->crc;
+		environment.flags	= NULL;
+		environment.data	= single->data;
 	}
 
-	crc1_ok = ((crc1 = crc32 (0, (uint8_t *) environment.data, ENV_SIZE))
-			   == environment.crc);
-	fprintf(stderr,
-		"crc is: %d\n env crc is: %lu\n",
-		crc1, environment.crc);
+	dev_current = 0;
+	if (flash_io (O_RDONLY))
+		return -1;
+
+	crc0 = crc32 (0, (uint8_t *) environment.data, ENV_SIZE);
+	crc0_ok = (crc0 == *environment.crc);
 	if (!HaveRedundEnv) {
-		if (!crc1_ok) {
+		if (!crc0_ok) {
 			fprintf (stderr,
 				"Warning: Bad CRC, using default environment\n");
 			memcpy(environment.data, default_environment, sizeof default_environment);
 		}
 	} else {
-		flag1 = environment.flags;
+		flag0 = *environment.flags;
 
-		curdev = 1;
-		if ((addr2 = calloc (1, ENV_SIZE)) == NULL) {
+		dev_current = 1;
+		addr1 = calloc (1, CONFIG_ENV_SIZE);
+		if (addr1 == NULL) {
 			fprintf (stderr,
 				"Not enough memory for environment (%ld bytes)\n",
-				ENV_SIZE);
-			return (errno);
+				CONFIG_ENV_SIZE);
+			return -1;
 		}
-		environment.data = addr2;
+		redundant = addr1;
 
-		if (flash_io (O_RDONLY)) {
-			return (errno);
+		/*
+		 * have to set environment.image for flash_read(), careful -
+		 * other pointers in environment still point inside addr0
+		 */
+		environment.image = addr1;
+		if (flash_io (O_RDONLY))
+			return -1;
+
+		/* Check flag scheme compatibility */
+		if (DEVTYPE(dev_current) == MTD_NORFLASH &&
+		    DEVTYPE(!dev_current) == MTD_NORFLASH) {
+			environment.flag_scheme = FLAG_BOOLEAN;
+		} else if (DEVTYPE(dev_current) == MTD_NANDFLASH &&
+			   DEVTYPE(!dev_current) == MTD_NANDFLASH) {
+			environment.flag_scheme = FLAG_INCREMENTAL;
+		} else {
+			fprintf (stderr, "Incompatible flash types!\n");
+			return -1;
 		}
 
-		crc2_ok = ((crc2 = crc32 (0, (uint8_t *) environment.data, ENV_SIZE))
-				   == environment.crc);
-		flag2 = environment.flags;
-
-		if (crc1_ok && !crc2_ok) {
-			environment.data = addr1;
-			environment.flags = flag1;
-			environment.crc = crc1;
-			curdev = 0;
-			free (addr2);
-		} else if (!crc1_ok && crc2_ok) {
-			environment.data = addr2;
-			environment.flags = flag2;
-			environment.crc = crc2;
-			curdev = 1;
-			free (addr1);
-		} else if (!crc1_ok && !crc2_ok) {
+		crc1 = crc32 (0, (uint8_t *) redundant->data, ENV_SIZE);
+		crc1_ok = (crc1 == redundant->crc);
+		flag1 = redundant->flags;
+
+		if (crc0_ok && !crc1_ok) {
+			dev_current = 0;
+		} else if (!crc0_ok && crc1_ok) {
+			dev_current = 1;
+		} else if (!crc0_ok && !crc1_ok) {
 			fprintf (stderr,
 				"Warning: Bad CRC, using default environment\n");
-			memcpy(environment.data, default_environment, sizeof default_environment);
-			curdev = 0;
-			free (addr1);
-		} else if (flag1 == active_flag && flag2 == obsolete_flag) {
-			environment.data = addr1;
-			environment.flags = flag1;
-			environment.crc = crc1;
-			curdev = 0;
-			free (addr2);
-		} else if (flag1 == obsolete_flag && flag2 == active_flag) {
-			environment.data = addr2;
-			environment.flags = flag2;
-			environment.crc = crc2;
-			curdev = 1;
-			free (addr1);
-		} else if (flag1 == flag2) {
-			environment.data = addr1;
-			environment.flags = flag1;
-			environment.crc = crc1;
-			curdev = 0;
-			free (addr2);
-		} else if (flag1 == 0xFF) {
-			environment.data = addr1;
-			environment.flags = flag1;
-			environment.crc = crc1;
-			curdev = 0;
-			free (addr2);
-		} else if (flag2 == 0xFF) {
-			environment.data = addr2;
-			environment.flags = flag2;
-			environment.crc = crc2;
-			curdev = 1;
+			memcpy (environment.data, default_environment,
+				sizeof default_environment);
+			dev_current = 0;
+		} else {
+			switch (environment.flag_scheme) {
+			case FLAG_BOOLEAN:
+				if (flag0 == active_flag &&
+				    flag1 == obsolete_flag) {
+					dev_current = 0;
+				} else if (flag0 == obsolete_flag &&
+					   flag1 == active_flag) {
+					dev_current = 1;
+				} else if (flag0 == flag1) {
+					dev_current = 0;
+				} else if (flag0 == 0xFF) {
+					dev_current = 0;
+				} else if (flag1 == 0xFF) {
+					dev_current = 1;
+				} else {
+					dev_current = 0;
+				}
+				break;
+			case FLAG_INCREMENTAL:
+				if ((flag0 == 255 && flag1 == 0) ||
+				    flag1 > flag0)
+					dev_current = 1;
+				else if ((flag1 == 255 && flag0 == 0) ||
+					 flag0 > flag1)
+					dev_current = 0;
+				else /* flags are equal - almost impossible */
+					dev_current = 0;
+				break;
+			default:
+				fprintf (stderr, "Unknown flag scheme %u \n",
+					 environment.flag_scheme);
+				return -1;
+			}
+		}
+
+		/*
+		 * If we are reading, we don't need the flag and the CRC any
+		 * more, if we are writing, we will re-calculate CRC and update
+		 * flags before writing out
+		 */
+		if (dev_current) {
+			environment.image	= addr1;
+			environment.crc		= &redundant->crc;
+			environment.flags	= &redundant->flags;
+			environment.data	= redundant->data;
+			free (addr0);
+		} else {
+			environment.image	= addr0;
+			/* Other pointers are already set */
 			free (addr1);
 		}
 	}
-	return (0);
+	return 0;
 }
 
 
@@ -715,18 +1044,20 @@
 	if (get_config (CONFIG_FILE)) {
 		fprintf (stderr,
 			"Cannot parse config file: %s\n", strerror (errno));
-		return 1;
+		return -1;
 	}
 #else
 	strcpy (DEVNAME (0), DEVICE1_NAME);
 	DEVOFFSET (0) = DEVICE1_OFFSET;
 	ENVSIZE (0) = ENV1_SIZE;
 	DEVESIZE (0) = DEVICE1_ESIZE;
+	ENVSECTORS (0) = DEVICE1_ENVSECTORS;
 #ifdef HAVE_REDUND
 	strcpy (DEVNAME (1), DEVICE2_NAME);
 	DEVOFFSET (1) = DEVICE2_OFFSET;
 	ENVSIZE (1) = ENV2_SIZE;
 	DEVESIZE (1) = DEVICE2_ESIZE;
+	ENVSECTORS (1) = DEVICE2_ENVSECTORS;
 	HaveRedundEnv = 1;
 #endif
 #endif
@@ -734,14 +1065,14 @@
 		fprintf (stderr,
 			"Cannot access MTD device %s: %s\n",
 			DEVNAME (0), strerror (errno));
-		return 1;
+		return -1;
 	}
 
 	if (HaveRedundEnv && stat (DEVNAME (1), &st)) {
 		fprintf (stderr,
 			"Cannot access MTD device %s: %s\n",
 			DEVNAME (1), strerror (errno));
-		return 1;
+		return -1;
 	}
 	return 0;
 }
@@ -754,33 +1085,37 @@
 	int rc;
 	char dump[128];
 
-	if ((fp = fopen (fname, "r")) == NULL) {
-		return 1;
-	}
-
-	while ((i < 2) && ((rc = fscanf (fp, "%s %lx %lx %lx",
-				  DEVNAME (i),
-				  &DEVOFFSET (i),
-				  &ENVSIZE (i),
-				  &DEVESIZE (i)  )) != EOF)) {
+	fp = fopen (fname, "r");
+	if (fp == NULL)
+		return -1;
 
+	while (i < 2 && fgets (dump, sizeof (dump), fp)) {
 		/* Skip incomplete conversions and comment strings */
-		if ((rc < 3) || (*DEVNAME (i) == '#')) {
-			fgets (dump, sizeof (dump), fp);	/* Consume till end */
+		if (dump[0] == '#')
 			continue;
-		}
+
+		rc = sscanf (dump, "%s %lx %lx %lx %lx",
+			     DEVNAME (i),
+			     &DEVOFFSET (i),
+			     &ENVSIZE (i),
+			     &DEVESIZE (i),
+			     &ENVSECTORS (i));
+
+		if (rc < 4)
+			continue;
+
+		if (rc < 5)
+			/* Default - 1 sector */
+			ENVSECTORS (i) = 1;
 
 		i++;
 	}
 	fclose (fp);
 
-	fprintf(stderr,
-		"number of banks: %d\n devname: %s\n devoffset: %lx\n envsize: %lx\n devsize: %lx\n",
-		i,DEVNAME(i-1),DEVOFFSET(i-1),ENVSIZE(i-1),DEVESIZE(i-1));
 	HaveRedundEnv = i - 1;
 	if (!i) {			/* No valid entries found */
 		errno = EINVAL;
-		return 1;
+		return -1;
 	} else
 		return 0;
 }
diff -Naur env/fw_env.config env2/fw_env.config
--- env/fw_env.config	2015-04-28 14:52:27.271689622 -0700
+++ env2/fw_env.config	2009-01-28 12:44:51.000000000 -0700
@@ -1,12 +1,11 @@
 # Configuration file for fw_(printenv/saveenv) utility.
-# Up to two entries are valid, in this case the redundand
+# Up to two entries are valid, in this case the redundant
 # environment sector is assumed present.
+# Notice, that the "Number of sectors" is ignored on NOR.
 
-# MTD device name	Device offset	Env. size	Flash sector size
-/dev/mtd0		0x80000		0x4000		0x20000
-
-##define CFG_ENV_ADDR            0
-#define CFG_ENV_SIZE            0x4000  /* Total Size of Environment Sector */
-#define CFG_ENV_RANGE           0x80000 //1 block size
-#define CFG_ENV_OFFSET          0x80000 //2nd block
+# MTD device name	Device offset	Env. size	Flash sector size	Number of sectors
+/dev/mtd1		0x0000		0x4000		0x4000
+/dev/mtd2		0x0000		0x4000		0x4000
 
+# NAND example
+#/dev/mtd0		0x4000		0x4000		0x20000			2
diff -Naur env/fw_printenv env2/fw_printenv
--- env/fw_printenv	2015-04-28 17:16:04.631851401 -0700
+++ env2/fw_printenv	1969-12-31 17:00:00.000000000 -0700
@@ -1,96 +0,0 @@
-ELF          (      4   >    4    (     p 9                       4   4  4                 4  4  4                           9  9           9  9 9 @             9  9 9                H  H  H                Qtd                          /lib/ld-linux.so.3           GNU                 #   !            "                                                                                  	       
-                                                                                          t   x                                ,                                                &               5                                                   s            y            '                                       ,            8            D            P            \            h            t                                    ;          <                  j            I                                                  libgcc_s.so.1 __aeabi_unwind_cpp_pr0 __gmon_start__ _Jv_RegisterClasses __aeabi_unwind_cpp_pr1 libc.so.6 _IO_putc fopen strrchr abort fgets calloc strlen __errno_location read stdout __isoc99_fscanf fputs lseek memcpy fclose malloc stderr ioctl fwrite fprintf strcmp strerror __libc_start_main free __xstat GCC_3.5 GLIBC_2.7 GLIBC_2.4                                                     U&y   4        `          ii   <     ii   F      4;   ;    <   :   :   :   :   :   :   :   : 
-  :   :   :   :   :   :   :   :    ;   ;   ;   ;   ;   ;   ;   ;    ;   $;   (;    ,; !  0; "  @-k  -@   @ 8 0 (                        x p h `    - -- 0,     0  0 0    R/     0    R   /<   @- 0  S0  S3/9     - M  000z  0 0 00" P2!0#40"00000 0 00" 2!0#40"00000 0 00" 1!0#40"00000 0 00" 1!0#40"00000 0 00" `1!0#40"00000 0 00" $1!0#40"00000 0 00" 0!0#40"00000 0 00" 0!0#40"000000C00 S0  S  
-0 0 00" L0!0#40"000000C00  S00  /   H-M  0  M 000 K - M\0  X 010b1 00 00C000 0  S  
-00C00  /@< < P< H-M    0  S  
- 01  000(  00  0@ 0 0 R   0 0 %  0  0000 0  S    000  S  000  0  0 0  S 0 KD<    < H-,M0 4 00  0  S  
- 0  00 S)  20(0  (0$0  2@ 0 $0 R  t"t2 0 % z 0  $00$0$0 0  S( x$00(0(0 0  S 0  400 0  r 0  S  0040040000C0000 S  
-!1 0 4 K 0b   00     0 0V   0!400 00 00T10(06  (0$0  81@. 0 $0 R  !1 0 % $ 0;  $00$0$0 0  S (  000  S  
-0  S
-   0 0 "0 0=    $00(0(0 0  S0  S	  T0 0 X0   00 00 0  00 R0 KD<    < @  D  ; |  pH-,M8 < 0 080 S  0,   0  S  
- 0 0$ <00 0040(0(0$0%  (0$0  d4@ 0 $0 R  H$H4 0 % 0 $00$0$0 0  S (  0 0 0  S  $00(0(0 0  S      0  S4  
-  0  S	  3 0 3  0  $00$0$0 0  S  (0      $0  (0  $00$0(0 0  S  $0 0  S  
-(00(0  (00(0(0    80 S  20(0  (00(0(0 0  S(00 0  S2 (0 R  *(00(0 1 00,0000  00!<00 0 $  ,000,0000000 80 R2@ 00 (0 c,0 R  1 0 1   0k  (00(0     0  (0  (0 0  S 000     S000"  00!<00 0000 S  =0    0(  0(00(00  (0  (0 0  S 000     S000000 80 R(00(0(0         0@ 0     x0  x0 0`|P`0 @ 0      0  S  
-H 00 0 #  0    0 KpD<    <           H-8M@  00|=  010b!h=0 @K 04040  S  D= 0`<],=  010b!=@ 0 0 8 0  o 05 0$0< 0  S  
-$00$0@0 S < 0  S+  
-< 0  S 00(0( 010b!t<0 @ 00000  S  P< 0`H\( 010b!(<@N 0 0  0  3 0 ; 0(04000     .( 010b1 00 080( 010b1 00 0<0<0K0  l; 0  S   
-L;  H010b1 00 080;  010b1 00 0<0<0K4  :  : 
-( 
-010b1 00 :   010b10 0 00c 0 0  Sm  
- 0  000  S  @: 0PTJ 0 0  0    0| ( 	010b1 00 9   010b10 0 000    0 s  9 0`Y( 010b!d9@ 0 0 K 0   0H  00  c 0,0,  0 R  
-9 0` Y( 010b!8@{ 0 0 ) 0  ` 0& b( 010b1 00 080( l010b1 00 0<0<0K0 p / 0  S  
-(8 0`PX( 010b! 8@D 0 0  0  ) 0 +( 010b!7( 010b100 0 ( l010b1 00 00    0 s  07 0`HW( 010b!7@ 0 0  0   0 $00   00 $0 R  
-6 0`V( 010b!6@ 0 0  0   $     0 T6@ 00   0@ 0 T  
-6 0p8f( 010b!5P 0 0 i @ 0 0  0 0b  0  S"  
- 00  }   0 R  
-h5 0`UP5  010b!<5@ 0 0 A 0  x 0>  Y5 0  SI  
-4  010b1 00 004   i 0 s  4 0`T4  010b!x4@b 0 0  0  G 0 4  , 0 S  
-(4 0`hT4  010b!3@C 0 0  0  ( 0  *(( 010b1 00 080( 010b1 00 0<0<0K0  T3 0  S8  
-43  0010b1 00 0803   010b1 00 0<0<0K4 ( 0  0  S  
-2 0` S( 010b!2@ 0 0  0   0  tq  D2  @010b1 00 04    0 s  2 0`R1  010b!1@ 0 0 h 0   0e  $04    $0 R  
-1 0`Qh1  010b!T1@ 0 0 G 0  ~ 0D  81@t 04  \ 0,0,@k 0 T  
-0 0`8Q0  010b!0@r 0 0   0  W 0  4 M 0  S  
-p0 0`PX0  010b!D0@U 0 0  0  : 0    0 K@< <  < 0  P< D  M@@; D< X  `  |      M@      H  x  T<     M@      - M   0 0= S 000     S  
-0  0  0 0 R 000     S0 0  S  00C 0= S  0    0  /0H- MT  0  S  
-0B  0  0 0 0  S  4 0PD 0   0 0* 4   4      $ 0  S  
- 0 0 |4@ 0    0(0( P4 0 R 00$004 04$(4 0 ( 4 0  S  $0  S  $3 0 , 30  ~  300K3   } 0 Z 000  S  t3 0PlCo 0  o 0 0  D3     0  S  
-t 0 0  3@W 0    00 2 0 R 000200K$0  S  
-0  S  2   2 [ ( 2  2       $0  S  0  S  
-X2  L2 [  <2  82       $0  S  0  S  "1 0 , 10  1      i  1 0 [ R  1 0 [ R  1   1 [ ( t1  p1     P  p1 0 [ R  X1 0 [ R  ,1   1 [  1  1     7   [0[ R  0   0 [ ( 0  0     $  0[ S  0   0 [ ( |0  x0       0[ S  P0  D0 [  40  00           0 K0 <    D< @< 0  P< P  D; @; T< pH-\M4S   0  S  
-$1 0PA 0 0 C 0  z06   l0K U  0  S  
-0 0`P@| 0 0 * 0  a0  0 0  S  
- l0K 8  0  S  
-P0 0`PPT@_ 0 0  0  D0    0 Kp   <   <   P< $< pH-M  00 P2  0 0 0  S  0  0 S	   010b10 0# S  0K     0000 S+   010b!1 010b1 1 010b1 l10  010b1 H10  0   0 000 s  1 0 0 C010b!00 C@010b100 @0 CP010b100 0 C|`P010b100 0 @0 00 CH0  0  S   0   0    0 Kp  <    <   P<  H-M 0 00 /k 000  S  
-000  0  S	    0  S  
-0   0   h} 0  S	    0  S  
-0
-   0  00 0 (0  Y0 K <  H   < T  /G- p`0  c
-I@   PI</	 TP(  U  
-0  @3/	 T(P  </@1  3/	 T:X     @-      0w,aQ	mjp5cd2y+L	|~-d jHqA}mQVlkdzbeO\lcc= n;^iLA`rqg<GKk
-5lB@l2u\EY=0&: QQa!#V(_$|o/LhXa=-fAvq *q3x4 	j-=mld\cQkkbal0eN bl{WeP|bI-|eLXaMQ:t 0AJ=mjiCn4Fg`s-D3_L
-|<qPA' %hWo 	fa^)"=Y.;\l t9Gw&sc;d>jmZjz	' 
-}Dhi]Wbgeq6lknv+ZzJgoC`~8ROggW?K6H+L
-J6`zA`Ugn1yiFafo%6hRwG"/&U;(Z+j\1,[d&cju
-m	?6grW Jz+{8|!Bhn[&wowGZpj;f\eibkaElx
-TN9a&g`MGiIwn>JjZf@;7SG00S$6)WTg#.zfJah]+o*7Z-## Error: environment not terminated
-   -n  ## Error: `-n' option requires exactly one argument
-    ## Error: "%s" not defined
- serial# Can't overwrite "%s"
-   Error: environment overflow, "%s" deleted
-  updated crc is %ld
- env size is %ld
-    Error: can't write fw_env to flash
- Can't open %s: %s
-  Unlocking flash...  Done    Cannot malloc %d bytes: %s
- seek error on %s: %s
-   read error on %s: %s
-   Erasing old environment...  MTD erase error on %s: %s
-  Writing environment to %s...
- with offset: %lu
- CRC write error on %s: %s
- wrote %d/%d bytes only 
- Write env data error on %s: %s
- env size: %ld
-  write error on %s: %s
-  Write error on %s: %s
-  Locking ... I/O error on %s: %s
-    CRC read error on %s: %s
-   Read error on %s: %s
-   Not enough memory for environment (%ld bytes)
-  crc is: %d
- env crc is: %lu
-    Warning: Bad CRC, using default environment
-    /etc/fw_env.config  Cannot parse config file: %s
-   Cannot access MTD device %s: %s
-    r   %s %lx %lx %lx  number of banks: %d
- devname: %s
- devoffset: %lx
- envsize: %lx
- devsize: %lx
-   fw_printenv fw_setenv   Identity crisis - may be called as `fw_printenv' or as `fw_setenv' but not as `%s'
-      @    A    A    C    D    B    C    C    @        tHplptxTtx|T\   P  4               `      X          9          9          h     p     @  
-   P                  :                p     X              o  o   o                                                  9         d  d  d  d  d  d  d  d  d  d  d  d  d  d  d  d  d  d  d  d  d  d  d  d  d  d  d  d  d                 bootcmd=bootp; setenv bootargs root=/dev/nfs nfsroot=${serverip}:${rootpath} ip=${ipaddr}:${serverip}:${gatewayip}:${netmask}:${hostname}::off; bootm bootdelay=5 baudrate=115200   A*   aeabi     5TE 	, GCC: (Sourcery G++ Lite 2010q1-202) 4.4.1  GCC: (Sourcery G++ Lite 2010q1-202) 4.4.1  GCC: (Sourcery G++ Lite 2010q1-202) 4.4.1     |        ,             0     B B    |    D         .symtab .strtab .shstrtab .interp .note.ABI-tag .hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .text .fini .rodata .ARM.extab .ARM.exidx .init_array .fini_array .jcr .dynamic .got .data .bss .ARM.attributes .comment .debug_frame                                                     4  4                    #         H  H                     1         h  h                  7         @  @  0              ?         p  p  P                 G   o       F                T   o       P                c   	      X  X                  l   	      p  p                 u         X  X                    p         d  d  p                {             8'                            0                               0                              8  x                       p       9                            9 9                             9 9                             9 9                             9 9                           : :                            8; 8;                             ; ;  `                       p        ;  +                                #<                                  <  d                                =                                 B       ~         	              <N  O                                     4            H            h            @            p                                    X            p       	     X       
-     d                                                                         9           9           9           9           :           8;           ;                                                                           ,            X        
-                H                                                                         8;           `        
-                         )   9          <;           4         6   4           L         L   <         (            9        [   9          P            P           x                        9           9          <                                                                     8                                                < 8        <           @<         D<         P<         @;         T<         A;          D;         `         "  `  |                    H                                 -    d    6                                                                     ?                                                        H  0  d                   0         U           x                                 `              <                                                          n              ,                                              y                                      T                         9          9         :        9         9         9         d            t            x           8;          x                                 ,                 &           9           V             v                                                                                                                         &       " +         :        D           T           d            u  8;                 ;        ,           8           D           <;        X<        0         X<        P           \           h         1        ;  ;      G  t         Z    D     c           u  X<                   X<        ;         <                   ;                                                    3         8  X       
- >            $a call_gmon_start $d init.c crtstuff.c __JCR_LIST__ __do_global_dtors_aux completed.6102 __do_global_dtors_aux_fini_array_entry frame_dummy __frame_dummy_init_array_entry crc32.c crc_table fw_env.c envdevices curdev environment HaveRedundEnv active_flag obsolete_flag default_environment getenvsize env_init envmatch flash_io parse_config get_config fw_env_main.c elf-init.c stat.c __JCR_END__ _GLOBAL_OFFSET_TABLE_ __init_array_end __init_array_start _DYNAMIC data_start open@@GLIBC_2.4 strerror@@GLIBC_2.4 abort@@GLIBC_2.4 __libc_csu_fini _start __xstat@@GLIBC_2.4 __libc_start_main@@GLIBC_2.4 __aeabi_unwind_cpp_pr0@@GCC_3.5 __isoc99_fscanf@@GLIBC_2.7 __gmon_start__ _Jv_RegisterClasses fclose@@GLIBC_2.4 fgets@@GLIBC_2.4 _fini calloc@@GLIBC_2.4 fopen@@GLIBC_2.4 fw_printenv strrchr@@GLIBC_2.4 __stat stat _IO_stdin_used fw_getenv free@@GLIBC_2.4 read@@GLIBC_2.4 write@@GLIBC_2.4 __data_start crc32 __bss_start__ ioctl@@GLIBC_2.4 strlen@@GLIBC_2.4 memcpy@@GLIBC_2.4 __dso_handle __end__ __libc_csu_init __bss_end__ printf@@GLIBC_2.4 close@@GLIBC_2.4 fwrite@@GLIBC_2.4 fw_setenv __bss_start fprintf@@GLIBC_2.4 crc32_wd malloc@@GLIBC_2.4 _bss_end__ puts@@GLIBC_2.4 _end stdout@@GLIBC_2.4 stderr@@GLIBC_2.4 lseek@@GLIBC_2.4 _edata _IO_putc@@GLIBC_2.4 __aeabi_unwind_cpp_pr1@@GCC_3.5 strcmp@@GLIBC_2.4 __errno_location@@GLIBC_2.4 main _init fputs@@GLIBC_2.4 
\ No newline at end of file
diff -Naur env/README env2/README
--- env/README	2014-12-10 18:33:58.588994209 -0700
+++ env2/README	2009-01-28 12:44:51.000000000 -0700
@@ -22,9 +22,11 @@
 #define DEVICE1_OFFSET    0x0000
 #define ENV1_SIZE         0x4000
 #define DEVICE1_ESIZE     0x4000
+#define DEVICE1_ENVSECTORS     2
 #define DEVICE2_OFFSET    0x0000
 #define ENV2_SIZE         0x4000
 #define DEVICE2_ESIZE     0x4000
+#define DEVICE2_ENVSECTORS     2
 
 Current configuration matches the environment layout of the TRAB
 board.
@@ -46,3 +48,7 @@
 
 DEVICEx_ESIZE defines the size of the first sector in the flash
 partition where the environment resides.
+
+DEVICEx_ENVSECTORS defines the number of sectors that may be used for
+this environment instance. On NAND this is used to limit the range
+within which bad blocks are skipped, on NOR it is not used.
